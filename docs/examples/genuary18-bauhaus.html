<!doctype html>
<notebook theme="air">
  <title>Genuary#18: Bauhaus.</title>
  <script id="0" type="text/markdown">
    # Genuary#18: Bauhaus.

    ${quote}

    - Title: **Shapes with Pattern**
    - Twitter: https://twitter.com/subairui/status/1748588843677401190
    - Prompt: https://genuary.art/prompts#jan18

    Fills a grid with random shapes colored by patterns. The layout algorithm is implemented by [Claudio Esperança](https://observablehq.com/@esperanc/random-shapes-in-a-grid). The patterns is from Émile Cheysson’s palettes in *Album de Statistique Graphique*, as [implemented by Tom Shanley](/@tomshanley/cheysson-color-palettes).
  </script>
  <script id="318" type="application/vnd.observable.javascript">
    // From https://observablehq.com/@tomshanley/cheysson-color-palettes
    viewof selectPalette = {
      const defaultPalette = "sequential12516026";

      function radioLegend(p) {
        const backgroundcolor = "#f9ece3";
        const palette = palettes[p];
        const padding = 4;
        const rectWH = 18 + padding;

        let svg = d3
          .create("svg")
          .attr("height", rectWH)
          .attr("width", rectWH * palette.range.length);

        const defs = svg.append("defs").html(palette.patterns);

        let rects = svg
          .selectAll(".rect")
          .data(palette.rangeURLs)
          .enter()
          .append("rect")
          .attr("x", (d, i) => i * rectWH + padding)
          .attr("y", padding)
          .attr("width", rectWH - padding)
          .attr("height", rectWH - padding)
          .style("fill", (d) => d)
          .style("stroke", "black");

        return svg.node();
      }

      function createInput(typeP) {
        let inputs = [];

        typeP.forEach(function (p) {
          let isChecked = p == defaultPalette ? "checked" : "";
          inputs.push(html`
          <div>
            <label style="display: inline-block; margin: 5px 10px 3px 0; font-size: 0.85em;">
            <input type="radio" name="input" style="vertical-align: top; margin-left: 1px;" value=${p} ${isChecked}>
              ${p}<br>
              ${radioLegend(p)}
            </label>
          </div>`);
        });

        return inputs;
      }

      const mobileMenu = width < 700 ? true : false;

      if (mobileMenu) {
        let formSelect = 1;
        let keys = Object.keys(palettes).sort();
        let options = keys.map((k) => html`<option value=${k}>${k}`);

        formSelect = html`<select>
            ${options}
          </select>`;

        return formSelect;
      } else {
        const formRadio = html`
    <form style="display: grid; gap: 10px 15px; grid-template-columns: repeat(5, auto); grid-auto-flow: row;">
    <div display="grid">
    ${createInput([
      "category12511021",
      "category12512013",
      "category12512022",
      "category12516028",
      "category12526006",
      "category1252605"
    ])}
    </div>
    <div display="grid">
    ${createInput(["diverging12514031", "diverging12541021"])}
    </div>
    <div display="grid">
    ${createInput([
      "grouped12511007",
      "grouped12512014",
      "grouped1251203",
      "grouped12513018",
      "grouped12516011"
    ])}
    </div>
    <div display="grid">
    ${createInput([
      "grouped12516017",
      "grouped12516018",
      "grouped12516024",
      "grouped12518022",
      "grouped12521014"
    ])}
    </div>
    <div display="grid">
    ${createInput([
      "sequential12512012",
      "sequential12516026",
      "sequential12519027",
      "sequential12521019",
      "sequential12521025",
      "sequential12524016",
      "sequential13188028"
    ])}
    </div>
    </form>
    `;

        formRadio.oninput = () => (formRadio.value = formRadio.input.value);
        formRadio.oninput();

        return formRadio;
      }
    }
  </script>
  <script id="401" type="application/vnd.observable.javascript">
    viewof background = Inputs.color({ label: "Background Color", value: "#f9ece3" })
  </script>
  <script id="82" type="application/vnd.observable.javascript">
    viewof regenerate = Inputs.button("Regenerate")
  </script>
  <script id="7" type="application/vnd.observable.javascript" pinned="">
    {
      regenerate;

      const width = 640,
        height = 640,
        cols = 8,
        rows = 8,
        margin = 5,
        cellWidth = width / cols,
        cellHeight = height / rows,
        squares = fillWithSquares(cols, rows),
        colors = await patterns(palettes[selectPalette]),
        shapes = [rect, circle, diamond, x],
        n = colors.length,
        m = shapes.length;

      function draw(app) {
        app.append(cm.clear, { fill: background });

        app
          .data(squares)
          .append(cm.group, {
            x: (d) => d.col * cellWidth + margin,
            y: (d) => d.row * cellHeight + margin
          })
          .append(cm.path, {
            d: (d) => {
              const size = d.size * cellWidth - margin * 2;
              const path = shapes[cm.randomInt(0, m)];
              const ctx = cm.pathContext();
              path(ctx, 0, 0, size, size);
              return ctx.toArray();
            },
            fill: (d) => colors[cm.randomInt(0, n)],
            stroke: "black",
            strokeWidth: 2
          });
      }

      function dispose(app) {
        invalidation.then(() => app.dispose());
      }

      return cm.app({ width, height }).call(draw).call(dispose).start().node();
    }
  </script>
  <script id="376" type="application/vnd.observable.javascript" pinned="">
    function rect(ctx, x, y, size) {
      ctx.moveTo(x, y);
      ctx.lineTo(x + size, y);
      ctx.lineTo(x + size, y + size);
      ctx.lineTo(x, y + size);
      ctx.closePath();
    }
  </script>
  <script id="384" type="application/vnd.observable.javascript" pinned="">
    function circle(ctx, x, y, size) {
      ctx.arc(x + size / 2, y + size / 2, size / 2, 0, Math.PI * 2);
    }
  </script>
  <script id="388" type="application/vnd.observable.javascript" pinned="">
    function diamond(ctx, x, y, size) {
      ctx.moveTo(x + size / 2, y);
      ctx.lineTo(x, y + size / 2);
      ctx.lineTo(x + size / 2, y + size);
      ctx.lineTo(x + size, y + size / 2);
      ctx.closePath();
    }
  </script>
  <script id="392" type="application/vnd.observable.javascript" pinned="">
    function x(ctx, x, y, size) {
      const b = size / 2;
      const a = b / 2;
      ctx.moveTo(x + a, y);
      ctx.lineTo(x, y + a);
      ctx.lineTo(x + a, y + b);
      ctx.lineTo(x, y + b + a);
      ctx.lineTo(x + a, y + b + b);
      ctx.lineTo(x + b, y + b + a);
      ctx.lineTo(x + a + b, y + b + b);
      ctx.lineTo(x + b + b, y + a + b);
      ctx.lineTo(x + a + b, y + b);
      ctx.lineTo(x + b + b, y + a);
      ctx.lineTo(x + a + b, y);
      ctx.lineTo(x + b, y + a);
      ctx.closePath();
    }
  </script>
  <script id="353" type="application/vnd.observable.javascript" pinned="">
    function patterns(palette) {
      const patternElements = palette.patterns
        .replace(/\r?\n(?!<pattern)/g, "")
        .split(/\n/g);
      return Promise.all(patternElements.map(pattern));
    }
  </script>
  <script id="307" type="application/vnd.observable.javascript" pinned="">
    function pattern(patternElement) {
      const id = patternElement.match(/id="([^"]+)"/)[1];
      const width = patternElement.match(/width="([^"]+)"/)[1] ?? 100;
      const height = patternElement.match(/height="([^"]+)"/)[1] ?? 100;
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      const image = new Image();
      const svgContent = `
        <svg width="${width * 2}" height="${
        height * 2
      }" xmlns="http://www.w3.org/2000/svg" transform="scale(2, 2)">
            ${patternElement}
            <rect x="0" fill="url(#${id})" width="100%" height="100%"/>
        </svg>`;
      image.src = "data:image/svg+xml," + encodeURIComponent(svgContent);
      return new Promise((resolve) => {
        image.onload = () => {
          const pattern = context.createPattern(image, "repeat");
          const matrix = createMatrix(0.5);
          pattern.setTransform(matrix);
          resolve(pattern);
        };
      });
    }
  </script>
  <script id="309" type="application/vnd.observable.javascript" pinned="">
    function createMatrix(scale, rotation = 0) {
      const radian = (rotation * Math.PI) / 180;
      const matrix = {
        a: Math.cos(radian) * scale,
        b: Math.sin(radian) * scale,
        c: -Math.sin(radian) * scale,
        d: Math.cos(radian) * scale,
        e: 0,
        f: 0
      };
      return matrix;
    }
  </script>
  <script id="269" type="application/vnd.observable.javascript" pinned="">
    cm = require(await FileAttachment("cm@2.umd.min.js").url())
  </script>
  <script id="272" type="application/vnd.observable.javascript" pinned="">
    import { fillWithSquares } from "@esperanc/random-shapes-in-a-grid"
  </script>
  <script id="286" type="application/vnd.observable.javascript" pinned="">
    import { palettes } from "@tomshanley/cheysson-color-palettes"
  </script>
  <script id="41" type="application/vnd.observable.javascript" pinned="">
    import { quote } from "@pearmini/charming-shared"
  </script>
</notebook>
